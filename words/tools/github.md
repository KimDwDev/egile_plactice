# git hub project board

- 스크럼을 짜기 전에 우리가 가진 능력을 파악하는것도 매우 중요하다. 

- 스크럼의 백로그를 추적할 수 있게 도와주는 도구가 필요한것이다. 

- 깃허브 프로젝트는 이러한 것을 충족할 수 있다.

- github repository에 장점은 version을 컨트롤 할 수 있다는 장점이 있다.

- github repository는 Issues를 이용해서 관리할 수 있고 Pull requests를 이용할 수 있다는 부분에서 장점이 있다.

- github actions은 빌드하고 release 할 수 있는 파이프라인을 제공한다.

- DevOps에 핵심이 되는 기능이 바로 이 github actions에 기능이라고 할 수 있다. 

- 이 빌드/배포는 시간을 줄여주는 사용하는 도라고 할 수 있다.

- 깃허브 프로젝트는 repository에 일환이 아닌 독립적인 요소로 작용하려고 한다.

- github action은 제품에 관련된 부분만 이야기를 하는 것이지 학습, 우리가 해야 하는 그러한 플래닝 이런거랑은 관련이 많이 없다는 것을 알 수 있다.

- 플래닝이나 이러한 부분은 어떻게 관리하면 좋을지에 대해서 연구를 해봐야 할 것 같다. 

- 우리만의 slack을 파고 이를 이용해서 팀 관리를 하는 것이 좋지 않을까 라는 것이 정설이다.

- 깃허브 프로젝트를 학습하고 이에 대해서 연구를 진행할 수 있다. 

- github project는 해당 레포지토리에서 projects를 생성할 수 있다.

- 팀플래닝 플랫폼은 개발 및 테스트 우선순위를 지정하는 작업을 맡은 제공 팀을 위한 것이다. 

- 팀 플래닝은 팀 단위에 일정계획과 작업 분배 중심으로 이루어 진다. 

- 깃허브 프로젝트에서 프로젝트를 만드는 방법은 생성 후 이름을 지정해서 project를 관리할 수 있다.

- 상단에 있는 것은 가장 우선순위가 높은 것이고 하단에 있는것은 가장 우선순위가 낮은 것을 이야기 한다. 

- 백로그를 보는 방식 또한 테이블로 보는게 있고 리스트로 보는 방식이 있다. 

- Asignee을 이용해서 github 담당자를 배치할 수 있다. status를 이용해서 작업의 완료 상태를 관리할 수 있다. 

- 우선권을 이용해서 해당 항목에 중요성을 배치할 수 있다. 

- Prority를 이용해서 우선권을 설정할 수 있는 것이다. 

- iteration은 그룹 스프린트로서 해당 기능에 대한 기간을 설정할 수 있는 것이다. 

- start date, end date는 일반적인 scrum 프레임워크에서는 잘 사용하지 않는다.

- Estimate는 작업 예상치로서 얼마의 시간이 걸릴지에 대한 예측을 적어놓는 다는 것을 알 수 있다.

- 보통 Estimate는 피보나치를 사용한다고 한다. 따라서 이를 이용한다면 더 좋을 것으로 예상이 된다. 

- 스토리 포인트를 이용해서 Estimate를 설정할 수 있을 것이다. -> 대부분에 애자일에서는 효율적으로 작용할 수 있다는 점이다. 

- 우선순위는 우리가 아는 Should, must, have등 같이 그것을 설명해주는데 필요한 요소가 되어야 한다.

- 순서는 드래그를 통해서 백로그에 위치를 왔다갔다 할 수 있다.

- Estimate는 들어가는 작업량 등을 이야기 하고 Size는 예상되는 작업의 크기량을 이야기 한다. 

- 기본 이슈에 대해서 project issue 저장소를 따로 만드는 것이 좋아 보인다. 

- 백로그에서 점선 동그라미는 아직 작업에 들어가지 않는 백로그라고 생각하면 좋다.

- 해당 project는 리포지토리를 연동할 수 있고 그 리포지토리를 기반으로 개발을 진행할 수 있다. 

- 해당 백로그에는 convert issue 라는것이 있고 이를 바탕으로 repository를 연결할 수 있다는 점이다. 

- 즉 레포지토리는 그리고 해당 이슈는 pr과 연결을 할 수 있다. 

- 백로그를 이용해서 보여주고 싶은 열을 추가해서 보여줄 수 있다. 

- 이슈를 정하고 이 이슈에 대해서 pr을 연결할 수 있다. 

- 스프린트는 30일 이내인것이 좋고 스프린트에는 스프린트 계획이 있다. -> 합리적인 스프린트가 무엇이고 이를 실제로 전달하는 것이 중요하다. 

- 스프린트를 설정할때는 backlog를 리뷰하면서 우선순위를 정하는 것이고 -> 어는 범위까지 우리가 스프린트로 정할지 이야기를 해야하고 -> 우리 시프린트의 목표에 대해서 이야기 해야 한다. -> 제품 백로그 안에 아이템인 PBIs를 정하고 이에 대해서 우리가 설정을 해야 한다. -> 

- github project에서 PBI는 하나의 issue가 될 것이다.

- 하나의 PBI를 완성하기 위한 TASKS를 만들어서 관리해야 한다. 

### Tasks
- [ ] 로그인 UI 컴포넌트 만들기
- [ ] 로그인 API 연동
- [ ] 에러 처리 추가

- 이를 이용해서 처리하면 진행률을 알려준다.

- 스프린트에 대한 과정을 소개해야 한다 -> 그래서 어떻게 하면 좋을지 이에 대해서 틀을 잘 작성 해보자

- PBIs에 세부탭에 들어가서 이에 대한 Tasks를 설정해야 한다. 

- 우리가 product backlog에서 지정한 PBI은 이슈이고 거기서 Tasks를 나누는 단위는 sub issue를 생성해서 관리할 수 있다. 

- 해당 이슈의 서브를 만들때는 Task라는 라벨을 붙여야 하고 -> 추가적으로 project를 지정해주어야 한다. 

- 아래 create sub more issue 버튼을 클릭해서 이에 대해서 더 하위를 편하게 하위 모델을 만들 수 있다.

- 우리가 하나의 테이블을 만들고 필터링을 한다음에 저장을 하면 다음에도 그 테이블을 그 상태로 사용이 가능하다.

- 태스크에 대한 열에는 ParentIssue랑 Estimate, Iteration, Asignee, Status를 하는것이 좋다. 

- slice라는 옵션을 추가해서 각 라벨에 대한 표시를 할 수 있다.

- 우선 순위에 따라서 작업을 나눌수 있다는 점이다. 

- 작업 기반으로 filed sum을 이용해서 estimate가 얼마나 걸리는지 조사할 수 있다는 점이다. 

- 이 슬라이스를 이용해서 add item을 이용해서 새로운 아이템도 만들 수 있고 이를 이용해서 

- 얼마든지 추가가 가능하고 todo에서 done으로 해야 해당 작업이 끝난다는 것을 알 수 있다. 

- 해당 pr에 대해서 merge를 신청하고 그 merge에 대한 또 merge를 신청하면서 이에 대해서 pr을 작성하는 것이다. 

- 이를 바탕으로 estimate등에 작업을 할 수 있고 이에 대해서 제품 백로그도 이야기할 수 있다.

- 모든 PBIS는 두개의 pbis를 정할 수 있고 이에 대해서 제품 백로그를 보낼수 있다.

- PB, SB, TASK로 나누어서 관리할 수 있고 이를 바탕으로 각 issue에는 pr을 신청할 수 있다. 이를 바탕으로 관리가 가능

- Daily scrum은 15분 동안 우리가 무엇을 하고 있는지에 대한 이야기를 나누는 것이다 즉 스프린트 백로그에 대해서 어떤 일을 하는지에 대해서 이야기를 해야 한다. 

- 우리가 Daily scrum을 하기 위한 테이블로 Current iteration을 사용할 수 있다. -> 이를 이용해서 어떻게 진행할 것인지에 대해서 이야기를 할 수 있는 것이다.

- daily scrum에서는 24시간 동안 무엇을 했는지에 대해서 논의를 하고 앞으로의 24시간 동안 무엇을 할것인지에 대해서 논의를 할 수 있다. 

- PBIS를 완료하는데 집중해야 한다는 것이다. -> 

- 대부분의 스크럼 팀에서는 SIZE는 잘 안사용한다고 볼 수 있다. 

- current issue에 경우는 부모이슈, 서브이슈, label를 추가해서 확인할 수 있다는 점이다. 이때 label을 이용해서 구분해서 정의할 수 있다는 점이 인상적이라고 할 수 있다.  

- 대부분의 po는 user story에 관심이 많다. 

- 해당 task에는 Task title, Parent PBI가 적혀 있다. 

- 우리가 DAILY SCRUM을 할때 내생각에 따라서 바로 Done을 하는 것이 아니라 일단 스크럼때 소개를 하고 Done으로 옮겨야 하는 것이다. 

- 실질적으로 Done, in-progress가 변경이 되는 것은 바로 이 current iteration이라고 할 수 있다. 

- 생성은 다른 곳에서 진행을 하고 ( 역할에 따라서 하는것이 다르다. -> 이건 정리를 해야 겠다. )

- 만약 끝내지 못했고 중간에 남았다면 task를 줄이는 방식으로 얼마나 남았는지를 우리가 정해줄 수 있는 것이다.

- 완료가 되었을때는 estimate를 0으로 바꾸어서 시간을 업데이트를 해주어야 하는 것이다. 

- 보통은 User story를 건드는 것이 아닌 task를 건드는 방식으로 업데이트를 이루어 내는 것이 default라고 보통은 생각하게 되는 것이다.

- 사용자 스토리를 중심으로 개발자의 일일 스크럼을 마무리할 수 있고 이를 바탕으로 끝나는 것에대해서 우리가 볼수 있고 만역 태스크가 모두 되어서 100%가 되면 이때 uSER STORY를 애ㅜㄷDP ENAUS WHGEK. 

- 마지막에 User story에 estimate는 총 걸린 시간을 보통 적어서 이 팀이 이걸 끝내는데 얼마만큼의 시간이 걸리었는지에 대해서 기록하는 용도로 많이 사용한다. 

- 이렇게 github project를 이용해서 애자일하게 관리할 수 있는 것이다. -> 이를 바탕으로 애자일을 학습할 수 있다. 

- github에서는 차트를 볼 수가 있다 이때 Burn up이라는 차트를 확인할 수 있다. 

- 처음으로는 번업 차트를 보여준다. 차트는 복제를 할 수가 있다. 

- 첫 burn up 차트는 전체를 보여주다 보니 알기가 힘든데 이때 필터를 이용해서 원하는 태스크에 대한 burn up차트를 확인할 수 있다.

- 번업은 완료된 작업량을 번다운은 남은 작업량을 보여주는 차트로 번업은 장기 프로젝트를 파악하는데 좋고 burn down은 단기로 짧은 스프린트를 추적하는데 좋다 

- Configure 차트를 이용해서 차트를 정리할 수 있다. 

- 해당 스프린트에 대한 차트를 보고 싶다면 이 스프린트에 대한 정보를 확인할 수 있는 것이다. 

- 우리가 estimate를 줄여주어야 하는 이유중의 하나가 이 burn down을 설정하기 위해서이기도 하다 이를 바탕으로 우리가 얼마나 빠르게 이걸 진행을 했는지 보여줄 수 있다. 

- court를 이용해서 막대그래프로 피드백을 할 수 있는 것이다. 

- 이를 이용해서 PBI에 대해서 우리가 피드백하고 개선할 수 있는 것이다. 

- 템플릿은 우리가 만든것이 만약 마음에 드는 커스텀이라면 이를 템플릿화 할 수 있다. 

- 오른쪽위에 유저에 대한 커스텀 템플릿을 생성할 수 있다. 