# github action 실습 방법

- 여기서는 docker에 올리지만 우리는 naver webina로 올리는 방법을 학습할 예정이다.

- github action은 여러 이벤트가 발생했을때 이에 대해서 작동을 할 수 있게 해주는 여러가지 기능이 존재한다.

- github actions를 사용하면 yaml을 이용해서 이를 설정할 수 있다.

- 해당 workflows는 이벤트가 발생했을때 워크플로에 대해서 작동을 정의할 수 있다. 

- 러너는 트리거에서 워크플로를 실행할때 그 실행하는 것을 자동으로 프로비저닝 할 수 있다는 점이다. 

- gitbhub action은 호스팅 러너를 이용해서 해당 코드를 실행하는 가상 머신을 사용할 수 있다.

- 심지어 병렬로 프로비저닝 되고 실행이 된다.

- 해당 ci testing에 가장 기본적인 설정은 환경에서 rep을 clone 받고 install nodejs를 설치하고 테스트를 진행하는 방식으로 간단하게 예를 들어서 push 할때 이러한 과정을 거치게 된다.

- github action은 비용이 들고 이 비용에 대해서 추가 요금을 받는다는 것을 알 수 있다. -> self hosted runner의 경우는 아예 구입해서 사용할 수 있는데 여러가지를 커스터 마이징이 가능하다는 것을 알 수 있다.

- github는 workflow, jobs, steps로 나누어서 진행이 된다. 

- 이때 github action에 사용되는 concept은 yaml 파일을 이용해서 적용이 된다 즉 이를 이용해서 CI를 진행한다는 의미이다.

- github action을 이용해서 동기적으로 job을 동기적으로 처리할 수 있고 기본값은 병렬 처리라는 점을 기억해야 한다.

- github action에서는 job에 대해서 step을 나눈다. 이때 step은 코드를 빌드, 테스트, 배포 하는 것과 같은 특정 작업을 자동화 할 수 있다.

- github action에서는 run 키워드는 npm run을 말하는 것이고 name, with등을 이용해서 마치 docker-compose.yml 처럼 처리가 가능하다는 점을 알 수 있다.

- 자동화 논리에 대해서 용이하게 할 수 있고 프로젝트의 기능을 더 높일 수 있다 이때 Docker 레지스트리에 이미지를 빌드하고 푸시하는데 사용될 수 있고 이때 AKS를 이용해서 CLUSTER를 이용할 수 있다.

- github action을 vscode에서 사용하기 위해서 plugin을 이용해서 확장자를 넓힐 수 있다. 

- github actions 확장자를 설치하면 이에 대해서 오류 메시지나 이러한 부분을 빠르게 확인이 가능하다

- .github/workflows 폴더를 생성해야 하고 이 폴더 안에 파일 만이 github가 인식하고 사용할 수 있는 파일이다.

- workflows 폴더에서 yml 파일을 만들어서 이에 대해서 트리거를 설정할 수 있다. 

- jobs -> first_job -> runs-on 을이용할 수 있다. 여기서 first_job에 jobs의 이름은 언제든지 변경이 가능하다는 점이다.

- 여기서 조심해야 할점은 needs 부분에 사용하는 이름은 unique해야 한다는 점이다 이점을 항상 기억해야 한다.

- .github/workflows에서 실행한 파일은 rep에 actions에서 확인이 가능하다. 

- 이때 name: Checkout repository
  uses: actions/checkout@v4 이걸 이용해서 현재 rep에 코드를 가져와서 실행이 하겠다는 의미이다. 즉 checkout을 미리 명시해두어야 안전하게 코드 작성이 가능하다 이거다.

- 액션을 실시할때 github token을 사용한다는 것을 알 수 있다.

- github action은 저장소의 액세스할 수 없음으로 여기서 액세스할 수 있도록 이에 대해서 정의를 내려야 한다.

- 체크가 되어 있는건 github 에서 보장하는 거니ㅏ 이 부분은 꽤 중요하다.

- Checkout을 이용해서 github actions를 정의할 수 있다. 

- Shas를 이용해서 checkout의 버전을 숨길 수 있다.

- github marketplace를 이용해서 github와 관련된 앱을 설치할 수 있다.

- 현재 CHeckout은 version5는 나왔는데 version4가 더 안정적이라고 할 수 있다.

- 원하는 github actions에 trigger를 사용하기 위해서는 marketplace에서 적절한 market을 사용하는 것이 좋다.

- 로그에 대해서 문제점을 확인하려면 이데 대해서 로그도 확인할 수 있다.

- yaml파일에 맞게 | 를 이용하면 띄어서 사용이 가능하다

- yqml에서 해시는 #임을 알 수 있다.

- ubuntud 타사에 라이브러리가 없는 경우 이에 대해서 생성하는 것이 좋다.

- 완전히 docker 처럼 sudo apt-get을 사용해서 ubuntu에 패키지를 설치해주어야 한다.

- 만약 여러개의 github/workflows에서 만약 만들었다면 해당 trigger가 일어날때 한꺼번에 같이 이루어 진다는 점을 확인할 수 있다.

- uses는 새로운걸 사용하는 거고 run은 실행을 하겠다는 의미이다 이를 잘 구분해서 사용해야 한다.

- 여러 워크 플로우중 몇개의 workflow는 끄고 싶다면 disable을 사용해서 끌 수 있다.

- wordflow에서는 shell 스크립트도 사용이 가능하다

- shell을 실행할 때는 권한도 같이 주어야 여기서는 실행이 가능하다

- #!/bin/sh를 꼭 잘 붙여야 한다는 것을 기억해야 한다.

- 하나의 job에서는 build, test, deploy의 과정을 거친다는 것을 알 수 있다. 

- 기본적으로 병렬로 실행함으로 needs를 이용해서 처리하는 것이라는 것이다 따라서 이번에서는 모든 것이 순서대로 실행되도록 하는것이 좋다.

- needs를 이용해서 해당 작업이 끝날때 까지 기다릴 수 있다. 

- needs를 사용할때는 무한 루프가 나지 않도록 주의해주어야 한다.

- needs에서 []를 이용해서 여러개의 의존성을 부여할 수도 있다.

- 만약에 중간 작업이 해결되지 않으면 skiped을 한다.

- 만약 아티팩트가 없다면 새롭게 생성된 파일에 한해서는 접근할 수 없는 문제가 발생해 버린다 따라서 이에 대해서 처리를 해주어야 하는것이다. 

- 아티팩트는 하나의 job이 생성한 결과물을 아티팩트를 이용해서 옮길 수 있다는 점이다.

- 아티팩트를 사용할 때는 upload에 경우는 with를 이용해서 name, path를 지정할 수 있고 download에 경우는 name을 사용해서 받을 수 있다.

- 빌드한 파일을 아티팩트를 이용해서 사용할 수 있다는 점이다 즉 이 아티팩트를 이용해서 바로 닫히는것이 아닌 따로 사용이 가능한 부분이고 추가적으로 다운로드를 받아서 이를 실행해 볼 수 있다는 점이다.

- 이 파일은 기본적으로 파일을 저장하는 시간을 정할 수 있다.

- 계정에 따라서 허용되는 크기가 다르게 사용될 수 있다.

- 환경 변수는 어떻게 사용할 수 있는지에 대해서 연구를 해봐야 한다.

- docker를 사용해서 build하고 배포하고 싶을때 환경변수가 필요한데 이를 이용해서 yml을 작성할 수 있다. 

- env를 이용해서 파일의 환경 변수를 정할 수 있다는 점이다.

